#!/usr/bin/env cljs
(ns main
  #_(:lein [org.clojure/clojure "1.9.0-alpha10"]
           [org.clojure/clojurescript "1.9.216"])
  (:require [cljs.reader :as reader]
            [clojure.string :as s]))

;; TODO assert that clj and cljs dep is provided in every call to :lein
;; TODO assert that main/-main is defined

(defn slurp
  [path]
  (.readFileSync (js/require "fs") path "utf-8"))

(defn read-string
  [text]
  (let [buffer (-> text (s/replace #"#_" "") reader/push-back-reader)]
    (loop [forms []]
      (try
        (recur (conj forms (reader/read buffer :throw-on-error)))
        (catch :default ex
          (if (not= "EOF while reading" (.-message ex))
            (recur forms)
            forms))))))

(defn -main
  [filepath key]
  (let [key (reader/read-string key)
        text (slurp filepath)]
    (cond
      (#{:npm :lein :require} key) (some->> (read-string text)
                                     (filter seq?)
                                     (filter #(= 'ns (first %)))
                                     first
                                     (filter list?)
                                     (filter #(= key (first %)))
                                     first
                                     rest
                                     (map prn)
                                     dorun)
      (#{:macro :source} key) (let [sum (atom 0)
                                    forms (as-> text $
                                            (map (fn [char]
                                                   (condp = char
                                                     \( 1
                                                     \) -1
                                                     0)) $)
                                            (map vector (range) $ (map #(swap! sum + %) $))
                                            (partition-by #(= [0 0] (rest %)) $)
                                            (map (fn [x] [(ffirst x) (first (last x))]) $)
                                            (map (fn [[start end]] (s/join "" (subvec (vec text) start (inc end)))) $))]
                                (println
                                 (s/join ""
                                     (condp = key
                                       :source  (for [form forms]
                                                  (if (s/starts-with? (s/trim form) "(defmacro")
                                                    (s/join "\n" (map #(str ";; " %) (s/split-lines form)))
                                                    form))
                                       :macro (cons "(ns main)\n" (for [form forms
                                                                        :when (s/starts-with? (s/trim form) "(defmacro")]
                                                                    form)))))))))
