#!/usr/bin/env python3
import sys

starts = {'{', '[', '('}
ends = {'}', ']', ')'}

def parse(openstr, tokens):
    i, token = tokens.pop(0)
    if token in starts and not openstr:
        result = [i, '']
        while tokens[0][1] not in ends:
            openstr, val = parse(openstr, tokens)
            if isinstance(val, str):
                if val == '"': # should be aware of escaped quote, ie \", should skip
                    openstr = not openstr
                if not openstr and not val.strip() and not result[-1] == '':
                    result.append('')
                else:
                    result[-1] += val
            else:
                result.append(val)
        tokens.pop(0)
        return openstr, [x for x in result if isinstance(x, list) or str(x).strip()]
    elif token in ends and not openstr:
        raise Exception(f'unexpected {token}')
    else:
        return openstr, token.strip()

def parse_all(tokens):
    openstr = False
    while tokens:
        openstr, res = parse(openstr, tokens)
        if res:
            yield res

def prettyprint(xs, i=0, j=1):
    if isinstance(xs, list):
        print(('\n' + '  ' * i if j else '') + '[', end='')
        for j, x in enumerate(xs):
            prettyprint(x, i + 1, j)
        print(' ]', end='')
    else:
        print('', xs, end='')
    if i == 0:
        print()

def search(xs, f):
    for x in xs:
        if f(x):
            return x
        if isinstance(x, list):
            res = search(x, f)
            if res:
                return res

def find_macros(res):
    for i, r in enumerate(res):
        if len(r) >= 2 and r[1] == 'defmacro':
            yield r[0], res[i + 1][0]

def quote(x):
    if ';' in x.split('"')[0]:
        return x.split(';')[0].strip() + '\n'
    else:
        return x

def chunk(val, chunk_size):
    res = []
    for x in val:
        res.append(x)
        if len(res) == chunk_size:
            yield res
            res = []
    if res:
        yield res

if __name__ == '__main__':
    if len(sys.argv) != 3:
        print('usage: runclj-deps <file.cljs> <:lein|:npm|:macro|:source|:browser-mode>')
        sys.exit(1)
    path, token = sys.argv[1:]
    with open(path) as f:
        text = f.read()
    text = '\n'.join(quote(x) for x in text.splitlines())
    tokens = list(enumerate(text))
    res = list(parse_all(tokens))
    try:
        _n, _token, meta = search(res, lambda x: (isinstance(x, list) and len(x) >= 2 and x[1] == ':runclj'))
    except TypeError:
        print('error: you need a ^{:runclj} above your (ns), see https://github.com/nathants/runclj/blob/master/readme.md', file=sys.stderr)
        sys.exit(1)
    meta = meta[1:]
    meta = chunk(meta, 2)
    meta = dict(meta)

    if token in [':npm', ':lein', ':require']:
        try:
            meta = meta[token]
        except KeyError:
            pass
        else:
            for m in meta[1:]:
                print(str(m[1:]).replace("'", '').replace(',', ''))

    elif token.endswith('-mode'):
        if meta.get(token) == 'true':
            print(token, file=sys.stderr)
        else:
            sys.exit(1)

    elif token == ':ns':
        print(search(res, lambda x: (isinstance(x, list) and len(x) >= 2 and x[1] == 'ns'))[2])

    elif token == ':macro':
        ns = search(res, lambda x: (isinstance(x, list) and len(x) >= 2 and x[1] == 'ns'))[2]
        print(f'(ns {ns})')
        for j, k in find_macros(res):
            print(text[j:k])

    elif token == ':source':
        new_text = ''
        i = 0
        for j, k in find_macros(res):
            head = text[i:j]
            macro = text[j:k]
            tail = text[k:]
            macro = '\n'.join([';; ' + x if x.strip() else x for x in macro.split('\n')])
            new_text += head + macro
            i = k
        new_text += tail
        print(new_text)

    else:
        print('unknown token:', token)
        sys.exit(1)
