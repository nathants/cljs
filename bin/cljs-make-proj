#!/bin/bash
set -e
filepath=$1
root=$(cljs-root $filepath)

runner(){
cat <<EOF
(ns cljs-runner
  (:require [main :as main]
            [cljs.nodejs :as nodejs]))
(nodejs/enable-util-print!)
(defn run [& _]
  (apply main/-main (drop 2 (.-argv js/process))))
(set! *main-cli-fn* run)
EOF
}

fibers_runner(){
cat <<EOF
(ns cljs-runner
  (:require [main :as main]
            [cljs.nodejs :as nodejs]))
(nodejs/enable-util-print!)
(defn run [& _]
  (.run ((js/require "fibers") #(apply main/-main (drop 2 (.-argv js/process))))))
(set! *main-cli-fn* run)
EOF
}


dev(){
cat <<EOF
#!/usr/bin/env node
try { require('source-map-support').install(); } catch(e) {};
require("./out/goog/bootstrap/nodejs");
require("./out/dev.js");
require("./out/cljs_runner.js");
global.cljs_runner.run();
EOF
}

project() {
cat <<EOF
(defproject $(basename $filepath) "0.0.1"
  :dependencies [[com.cemerick/piggieback "0.2.1"]
                 $(cljs-deps $filepath :lein 2>/dev/null)
                ]
  :plugins [[lein-cljsbuild "1.1.3"]
            [lein-npm "0.6.2"]]
  :npm {:dependencies [
                       $([ -z "$noshell" ] && echo '[fibers "1.0.13"] [source-map-support "0.4.2"] [prompt "1.0.0"]')
                       $(cljs-deps $filepath :npm 2>/dev/null)
                      ]}
  :main repl
  :repl-options {:nrepl-middleware [cemerick.piggieback/wrap-cljs-repl]}
  ;; TODO instead of copying code in, link via source-paths so stack traces point to actual code files
  :cljsbuild {:builds [{:id "dev"
                        :source-paths ["src"]
                        :compiler {:output-to "out/dev.js"
                                   :output-dir "out"
                                   :source-map true
                                   :optimizations :none

                                   :pretty-print true
                                   :target :nodejs}}
                       {:id "release"
                        :source-paths ["src"]
                        :compiler {:output-to "out-release/release.js"
                                   :source-map "out-release/release.js.map"
                                   :output-dir "out-release"
                                   :optimizations :simple
                                   :cache-analysis true
                                   :target :nodejs}}

]})
EOF
}

repl() {
cat <<EOF
(ns repl
  (:require [cemerick.piggieback :refer [cljs-repl]]
            [cljs.repl.node :refer [repl-env]]))
(defn start-node-repl
  []
  (cljs-repl (repl-env)
             :analyze-path "src"
             :output-dir "out-repl"
             :optimizations :none
             :cache-analysis true
             :source-map true))
EOF
}

shell() {
cat <<EOF
(ns shell
  (:require [clojure.string :as s]))
(def fibers (js/require "fibers"))
(defn run
  [& cmd]
  (let [[cb cmd] (if (fn? (first cmd))
                   [(first cmd) (rest cmd)]
                   [identity cmd])
        cmd (s/join " " (map str cmd))
        fiber (.-current fibers)
        data (atom "")]
    (.error js/console (str "run: " cmd))
    (doto (.spawn (js/require "child_process") "bash" #js ["-c" cmd])
      (-> .-stdout (.on "data" #(do (dorun (map cb (s/split-lines (.toString % "utf8"))))
                                    (swap! data str %))))
      (-> .-stderr (.on "data" #(dorun (map println (s/split-lines (.toString % "utf8"))))))
      (-> (.on "close" #(let [val {:exit % :output @data :cmd cmd :cwd (.cwd js/process)}]
                          (if (zero? %)
                            (.run fiber @data)
                            (.throwInto fiber val))))))
    (.yield fibers)))
(defn prompt
  [text]
  (let [p (js/require "prompt")
        fibers (js/require "fibers")
        fiber (.-current fibers)]
    (.start p)
    (.get p [text] #(.run fiber (first (vals (js->clj %2)))))
    (.yield fibers)))
(defn slurp
  [path]
  (.readFileSync (js/require "fs") path "utf-8"))
(defn spit
  [path text]
  (.writeFileSync (js/require "fs") path text))
EOF
}

mkdir -p $root/src

[ ! -z "$noshell" ] && echo :noshell

if [ -z "$noshell" ]; then
    shell > $root/src/shell.cljs.tmp
    mv -f $root/src/shell.cljs.tmp $root/src/shell.cljs
fi

if [ -z "$noshell" ]; then
    fibers_runner
else
    runner
fi > $root/src/cljs_runner.cljs.tmp
mv -f $root/src/cljs_runner.cljs.tmp $root/src/cljs_runner.cljs

repl > $root/src/repl.clj.tmp
mv -f $root/src/repl.clj.tmp $root/src/repl.clj

dev > $root/dev.js.tmp
mv -f $root/dev.js.tmp $root/dev.js

project > $root/project.clj.tmp
mv -f $root/project.clj.tmp $root/project.clj
